Bottom: fd1407339bbe7b846768742eb643b41b22866012
Top:    1f0cf4320a815f24bd186a16c1f7e4a4eca6f36f
Author: scott snyder <sss@karma>
Date:   2020-02-12 11:16:29 -0500

Fix compilation warnings.


---

diff --git a/include/Tools/Fitter.h b/include/Tools/Fitter.h
index 778c12b..a260679 100644
--- a/include/Tools/Fitter.h
+++ b/include/Tools/Fitter.h
@@ -122,8 +122,8 @@ private:
    
    // No copy constructor or assignment needed so far. so private for safety
    // If they are needed, they need to be implemented in a clean way first!
-   Fitter( const Fitter& f ){};
-   Fitter& operator= ( Fitter const& f ){return *this;}
+   Fitter( const Fitter& f ) = delete;
+   Fitter& operator= ( Fitter const& f ) = delete;
    
 };
 
diff --git a/src/ILDImpl/MiniVector.cc b/src/ILDImpl/MiniVector.cc
index 7ce3c79..57dc82c 100644
--- a/src/ILDImpl/MiniVector.cc
+++ b/src/ILDImpl/MiniVector.cc
@@ -27,9 +27,9 @@ MiniVector::~MiniVector(){
 
 double * MiniVector::getPosition(){
 
-  double x_outer = HitVec[0]->getPosition()[0];
-  double y_outer = HitVec[0]->getPosition()[1];
-  double z_outer = HitVec[0]->getPosition()[2];
+  //double x_outer = HitVec[0]->getPosition()[0];
+  //double y_outer = HitVec[0]->getPosition()[1];
+  //double z_outer = HitVec[0]->getPosition()[2];
   
   double x_inner = HitVec[1]->getPosition()[0];
   double y_inner = HitVec[1]->getPosition()[1];
diff --git a/src/ILDImpl/MiniVectorHit01.cc b/src/ILDImpl/MiniVectorHit01.cc
index 3736d07..1836b29 100644
--- a/src/ILDImpl/MiniVectorHit01.cc
+++ b/src/ILDImpl/MiniVectorHit01.cc
@@ -28,10 +28,10 @@ MiniVectorHit01::MiniVectorHit01( MiniVector* miniVector , const SectorSystemVXD
    UTIL::BitField64  cellID( LCTrackerCellID::encoding_string() );
    cellID.setValue( HitVec[1]->getCellID0() );
    
-   int _layer = cellID[ LCTrackerCellID::layer() ] ; // +1 to take into account the IP (considered as layer 0 ) 
+   int layer = cellID[ LCTrackerCellID::layer() ] ; // +1 to take into account the IP (considered as layer 0 ) 
    int det_id = 0 ;
    det_id  = cellID[lcio::LCTrackerCellID::subdet()] ;
-   if ( det_id == lcio::ILDDetID::SIT) { _layer = _layer + 6; } 
+   if ( det_id == lcio::ILDDetID::SIT) { layer = layer + 6; } 
    
    //Set the position of the VXDHit01
    const double* pos= miniVector->getPosition();
@@ -40,14 +40,14 @@ MiniVectorHit01::MiniVectorHit01( MiniVector* miniVector , const SectorSystemVXD
    _z = pos[2]; 
 
    double _cosTheta = cos(miniVector->getTheta());
-   double _phi = miniVector->getPhi();
-   double _theta = miniVector->getTheta() ;
+   double phi = miniVector->getPhi();
+   //double theta = miniVector->getTheta() ;
 
-   if (_phi < 0.) _phi = _phi + 2*M_PI;   
+   if (phi < 0.) phi = phi + 2*M_PI;   
 
    // YV, for debugging. Calculate sector here and not through the IVXHit base class
    //calculateSector();
-   _sector = _sectorSystemVXD->getSector( _layer, _phi, _cosTheta );
+   _sector = _sectorSystemVXD->getSector( layer, phi, _cosTheta );
    
    //We assume a real hit. If it is virtual, this has to be set.
    _isVirtual = false;
diff --git a/src/ILDImpl/SectorSystemVXD.cc b/src/ILDImpl/SectorSystemVXD.cc
index 305d37c..584b8f1 100644
--- a/src/ILDImpl/SectorSystemVXD.cc
+++ b/src/ILDImpl/SectorSystemVXD.cc
@@ -80,7 +80,7 @@ int SectorSystemVXD::getSector( int layer , int phi , int theta ) const {
   
   //std::cout << "getting sector : layer " << layer << " phi " << phi << " theta " << theta << std::endl ;
 
-  if ( layer >= _nLayers ){
+  if ( layer >= static_cast<int>(_nLayers) ){
     
     std::stringstream s; 
     s << "Layer " << layer << " is too big, the outermost layer is layer " << _nLayers - 1 ;
@@ -89,7 +89,7 @@ int SectorSystemVXD::getSector( int layer , int phi , int theta ) const {
   }
 
   
-  if ( phi >= _nDivisionsInPhi ){
+  if ( phi >= static_cast<int>(_nDivisionsInPhi) ){
     
     std::stringstream s; 
     s << "Phi " << phi << " is too big, the highest phi division is " << _nDivisionsInPhi ;
@@ -99,7 +99,7 @@ int SectorSystemVXD::getSector( int layer , int phi , int theta ) const {
 
 
   
-  if ( theta >= _nDivisionsInTheta ){
+  if ( theta >= static_cast<int>(_nDivisionsInTheta) ){
     
     std::stringstream s;
     s << "Theta " << theta << " is too big, the highest theta division is " << _nDivisionsInTheta ;
@@ -126,7 +126,7 @@ int SectorSystemVXD::getSector( int layer , double phi , double cosTheta ) const
 
   //std::cout << "getting sector : layer " << layer << " phi " << iPhi << " theta " << iTheta << std::endl ;
 
-  if ( layer >= _nLayers ){
+  if ( layer >= static_cast<int>(_nLayers) ){
     
     std::stringstream s; 
     s << "Layer " << layer << " is too big, the outermost layer is layer " << _nLayers - 1 ;
@@ -135,7 +135,7 @@ int SectorSystemVXD::getSector( int layer , double phi , double cosTheta ) const
   }
 
   
-  if ( iPhi >= _nDivisionsInPhi ){
+  if ( iPhi >= static_cast<int>(_nDivisionsInPhi) ){
     
     std::stringstream s; 
     s << "Phi " << iPhi << " is too big, the highest phi division is " << _nDivisionsInPhi ;
@@ -145,7 +145,7 @@ int SectorSystemVXD::getSector( int layer , double phi , double cosTheta ) const
 
 
   
-  if ( iTheta >= _nDivisionsInTheta ){
+  if ( iTheta >= static_cast<int>(_nDivisionsInTheta) ){
     
     std::stringstream s;
     s << "Theta " << iTheta << " is too big, the highest theta division is " << _nDivisionsInTheta ;
diff --git a/src/ILDImpl/VXDHit01.cc b/src/ILDImpl/VXDHit01.cc
index 7cddba8..d3df777 100644
--- a/src/ILDImpl/VXDHit01.cc
+++ b/src/ILDImpl/VXDHit01.cc
@@ -47,15 +47,15 @@ VXDHit01::VXDHit01( TrackerHit* trackerHit , const SectorSystemVXD* const sector
    radius = sqrt(radius);
       
    double _cosTheta = (pos[2]/radius);
-   double _phi = atan2(pos[1],pos[0]);
-   double _theta = acos( _cosTheta ) ;
+   double phi = atan2(pos[1],pos[0]);
+   //double theta = acos( _cosTheta ) ;
       
-   if (_phi < 0.) _phi = _phi + 2*M_PI;   
+   if (phi < 0.) phi = phi + 2*M_PI;   
 
    // YV, for debugging. Calculate sector here and not through the IVXHit base class
    //calculateSector();
 
-   _sector = _sectorSystemVXD->getSector( _layer, _phi, _cosTheta );
+   _sector = _sectorSystemVXD->getSector( _layer, phi, _cosTheta );
 
    
    //We assume a real hit. If it is virtual, this has to be set.
diff --git a/src/ILDImpl/VXDSectorConnector.cc b/src/ILDImpl/VXDSectorConnector.cc
index 573d9c6..eedb1ab 100644
--- a/src/ILDImpl/VXDSectorConnector.cc
+++ b/src/ILDImpl/VXDSectorConnector.cc
@@ -43,7 +43,7 @@ std::set< int > VXDSectorConnector::getTargetSectors ( int sector ){
    int iTheta_Up  = iTheta + _neighTheta; 
    int iTheta_Low = iTheta - _neighTheta;
    if (iTheta_Low < 0) iTheta_Low = 0;
-   if (iTheta_Up  >= _nDivisionsInTheta) iTheta_Up = _nDivisionsInTheta-1;
+   if (iTheta_Up  >= static_cast<int>(_nDivisionsInTheta)) iTheta_Up = _nDivisionsInTheta-1;
    
    //*************************************************************************************
 
@@ -51,23 +51,23 @@ std::set< int > VXDSectorConnector::getTargetSectors ( int sector ){
    
    for( unsigned layerStep = 1; layerStep <= _layerStepMax; layerStep++ ){
      
-     if ( layer >= layerStep ){ // +1 makes sense if I use IP as innermost layer
+     if ( layer >= static_cast<int>(layerStep) ){ // +1 makes sense if I use IP as innermost layer
        
        unsigned layerTarget = layer - layerStep;
 
-        if (layerTarget >= 0 && layerTarget < _layerMax ){   // just a test to run cellular automaton over the whole VXD - SIT
+         if (static_cast<int>(layerTarget) < _layerMax ){   // just a test to run cellular automaton over the whole VXD - SIT
 	 
-	 for (int iPhi = iPhi_Low ; iPhi <= iPhi_Up ; iPhi++){
+	 for (int iPhi2 = iPhi_Low ; iPhi2 <= iPhi_Up ; iPhi2++){
 
-	   int ip = iPhi;
+	   int ip = iPhi2;
 	   
 	   // catch wrap-around
 	   if (ip < 0) ip = _nDivisionsInPhi-1;          
-	   if (ip >= _nDivisionsInPhi) ip = ip - _nDivisionsInPhi;
+	   if (ip >= static_cast<int>(_nDivisionsInPhi)) ip = ip - _nDivisionsInPhi;
 	   
-	   for (int iTheta = iTheta_Low ; iTheta <= iTheta_Up ; iTheta++){
+	   for (int iTheta2 = iTheta_Low ; iTheta2 <= iTheta_Up ; iTheta2++){
 	     
-	     targetSectors.insert( _sectorSystemVXD->getSector ( layerTarget , ip , iTheta ) ); 
+	     targetSectors.insert( _sectorSystemVXD->getSector ( layerTarget , ip , iTheta2 ) ); 
 	     
 	   }
 	 }
@@ -76,13 +76,13 @@ std::set< int > VXDSectorConnector::getTargetSectors ( int sector ){
    }
    
 
-   if ( layer > 0 && ( layer <= _lastLayerToIP ) ){
+   if ( layer > 0 && ( layer <= static_cast<int>(_lastLayerToIP) ) ){
       
      unsigned layerTarget = 0;
       
      for (int ip = iPhi_Low ; ip <= iPhi_Up ; ip++){
        
-       for (int iTheta = iTheta_Low ; iTheta <= iTheta_Up ; iTheta++){
+       for (int iTheta2 = iTheta_Low ; iTheta2 <= iTheta_Up ; iTheta2++){
 	 
 	 streamlog_out(DEBUG1) << " VXDSectorConnector: from layer " << layer << " to layer " << layerTarget << std::endl ;
 	 
diff --git a/src/Tools/Fitter.cc b/src/Tools/Fitter.cc
index dec3546..f691439 100644
--- a/src/Tools/Fitter.cc
+++ b/src/Tools/Fitter.cc
@@ -70,7 +70,7 @@ Fitter::Fitter( Track* track , MarlinTrk::IMarlinTrkSystem* trkSystem ): _trkSys
    
 }
 
-Fitter::Fitter( Track* track , MarlinTrk::IMarlinTrkSystem* trkSystem, int VXDFlag ): _trkSystem( trkSystem ){
+Fitter::Fitter( Track* track , MarlinTrk::IMarlinTrkSystem* trkSystem, int /*VXDFlag*/ ): _trkSystem( trkSystem ){
    
  
    _trackerHits = track->getTrackerHits();
@@ -242,7 +242,7 @@ void Fitter::fitVXD(){
       fit_status = _marlinTrk->fit() ; 
       
    }
-   catch( MarlinTrk::Exception e ){
+   catch( const MarlinTrk::Exception& e ){
       
       std::stringstream s;
       s << "Fitter::fit(): Couldn't fit, MarlinTrk->fit() gave: " << e.what() << "\n";
@@ -439,7 +439,7 @@ void Fitter::fit(){
       fit_status = _marlinTrk->fit() ; 
       
    }
-   catch( MarlinTrk::Exception e ){
+   catch( const MarlinTrk::Exception& e ){
       
       std::stringstream s;
       s << "Fitter::fit(): Couldn't fit, MarlinTrk->fit() gave: " << e.what() << "\n";
